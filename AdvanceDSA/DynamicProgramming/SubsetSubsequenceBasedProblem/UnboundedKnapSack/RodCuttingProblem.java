public class RodCuttingProblem {
    /*
     *  Problem Statement:  Rod Cutting Problem

        Problem Link: Rod Cutting Problem

        We are given a rod of size ‘N’. It can be cut into pieces. 
        Each length of a piece has a particular price given by the price array. 
        Our task is to find the maximum revenue that can be generated by selling 
        the rod after cutting( if required) into pieces.

        Sample Input 1:
            2
            5
            2 5 7 8 10
            8
            3 5 8 9 10 17 17 20
        Sample Output 1:
            12
            24
        Explanation Of Sample Input 1:
            Test case 1:

            All possible partitions are:
                1,1,1,1,1           max_cost=(2+2+2+2+2)=10
                1,1,1,2             max_cost=(2+2+2+5)=11
                1,1,3               max_cost=(2+2+7)=11
                1,4                 max_cost=(2+8)=10
                5                   max_cost=(10)=10
                2,3                 max_cost=(5+7)=12
                1,2,2               max _cost=(1+5+5)=12    

        Clearly, if we cut the rod into lengths 1,2,2, or 2,3, we get the maximum cost which is 12.


        Test case 2:

            Possible partitions are:
            1,1,1,1,1,1,1,1         max_cost=(3+3+3+3+3+3+3+3)=24
            1,1,1,1,1,1,2           max_cost=(3+3+3+3+3+3+5)=23
            1,1,1,1,2,2             max_cost=(3+3+3+3+5+5)=22
        and so on….

        If we cut the rod into 8 pieces of length 1, 
        for each piece 3 adds up to the cost. Hence for 8 pieces, we get 8*3 = 24.
            */
	public static int cutRod(int price[], int n) {
		// Write your code here.
		// return recursion(price, n-1, n);
		// int[][] dp = new int[n][n+1];

		// for(int[] row : dp) Arrays.fill(row,-1);

		// return memo(dp,price,n-1,n);

		// return tab(price,n,n);
		return tabOpt(price,n,n);
	}

	//here n == w(max weight in knapsack)
	static int recursion(int[] arr,int ind,int len){
		if(ind == 0){
			//here road lenth will be 1 (ind+1)
			//no need to devide 
			if(len > 0) return len*arr[0];
			return 0;
		}
		int notPic = recursion(arr, ind-1,len);
		int pick = Integer.MIN_VALUE;
		int roadLength = ind+1;
		if(roadLength <= len){
			pick = arr[ind] + recursion(arr, ind,len - roadLength);
		}

		return Math.max(pick,notPic);
	}

	//memoization
	static int memo(int[][] dp,int[] arr,int ind,int len){
		if(ind == 0){
			//here road lenth will be 1 (ind+1)
			//no need to devide 
			if(len > 0) return len*arr[0];
			return 0;
		}
		if(dp[ind][len] != -1) return dp[ind][len];
		int notPic = memo(dp,arr, ind-1,len);
		int pick = Integer.MIN_VALUE;
		int roadLength = ind+1;
		if(roadLength <= len){
			pick = arr[ind] + memo(dp,arr, ind,len - roadLength);
		}

		return dp[ind][len] = Math.max(pick,notPic);
	}

	//tabulation
	static int tab(int[] arr,int n,int len){
		int[][] dp = new int[n+1][len+1];

		//oth row and 0th coloum will be zero
		//we can igore this condition and start loop from 1
		// for(int j=0 ; j<= len ;j++){
		// 	//for 1'st row
		// 	if(j>0) dp[1][j] = j*arr[0];
		// 	else dp[1][j] = 0;
		// }

		for(int i=1;i<=n;i++){
			for(int j=0;j<=len;j++){
				int notPick = dp[i-1][j];
				int pick = Integer.MIN_VALUE;
				//here lenth will i --> as dp's i --> arr's i-1
				if(i <= j)
					pick = arr[i-1] + dp[i][j-i];

				dp[i][j] = Math.max(pick,notPick);
			}
		}

		return dp[n][len];
	}

	//space optimization
	static int tabOpt(int[] arr,int n,int len){
		int[] pre = new int[len+1];
		int[] cur = new int[len+1];

		//oth row and 0th coloum will be zero
		//we can igore this condition and start loop from 1
		// for(int j=0 ; j<= len ;j++){
		// 	//for 1'st row
		// 	if(j>0) pre[j] = j*arr[0];
		// 	else pre[j] = 0;
		// }

		for(int i=1;i<=n;i++){
			for(int j=0;j<=len;j++){
				int notPick = pre[j];
				int pick = Integer.MIN_VALUE;
				//here lenth will i --> as dp's i --> arr's i-1
				if(i <= j)
					pick = arr[i-1] + cur[j-i];

				cur[j] = Math.max(pick,notPick);
			}
			int[] temp = pre;
			pre = cur;
			cur = temp;
		}

		return pre[len];
	}
}